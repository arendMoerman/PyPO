<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PyPO User Manual: Physical Optics Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PyPO User Manual
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__public__api__po.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Physical Optics Methods</div></div>
</div><!--header-->
<div class="contents">

<p>This section contains a list of public <code>PyPO</code> methods which are used for performing physical optics related tasks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2d822ec75ec733bede10f444be4d1479"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga2d822ec75ec733bede10f444be4d1479">PyPO.System.System.removeField</a> (self, fieldName)</td></tr>
<tr class="memdesc:ga2d822ec75ec733bede10f444be4d1479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a PO field from system.  <br /></td></tr>
<tr class="separator:ga2d822ec75ec733bede10f444be4d1479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff726434bebd8ed64fd20f1cc141a080"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#gaff726434bebd8ed64fd20f1cc141a080">PyPO.System.System.removeCurrent</a> (self, currentName)</td></tr>
<tr class="memdesc:gaff726434bebd8ed64fd20f1cc141a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a PO current from system.  <br /></td></tr>
<tr class="separator:gaff726434bebd8ed64fd20f1cc141a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38481699a40b1e3044083a8382b8e7b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#gaf38481699a40b1e3044083a8382b8e7b">PyPO.System.System.removeScalarField</a> (self, fieldName)</td></tr>
<tr class="memdesc:gaf38481699a40b1e3044083a8382b8e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a scalar PO field from system.  <br /></td></tr>
<tr class="separator:gaf38481699a40b1e3044083a8382b8e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdcd5c907622e6f18bfabcf32dec6f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga4cdcd5c907622e6f18bfabcf32dec6f6">PyPO.System.System.readCustomBeam</a> (self, name_beam, name_source, comp, lam, normalise=True, scale=1)</td></tr>
<tr class="memdesc:ga4cdcd5c907622e6f18bfabcf32dec6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a custom beam from disk into the system.  <br /></td></tr>
<tr class="separator:ga4cdcd5c907622e6f18bfabcf32dec6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1632938e4cddce095271eba8fcc30910"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga1632938e4cddce095271eba8fcc30910">PyPO.System.System.runPO</a> (self, runPODict)</td></tr>
<tr class="memdesc:ga1632938e4cddce095271eba8fcc30910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate a PO propagation.  <br /></td></tr>
<tr class="separator:ga1632938e4cddce095271eba8fcc30910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83eea20f5bdafb3f99686f5b29da8b5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga83eea20f5bdafb3f99686f5b29da8b5f">PyPO.System.System.mergeBeams</a> (self, *beams, obj=&quot;fields&quot;, merged_name=&quot;combined&quot;)</td></tr>
<tr class="memdesc:ga83eea20f5bdafb3f99686f5b29da8b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge multiple beams that are defined on the same surface.  <br /></td></tr>
<tr class="separator:ga83eea20f5bdafb3f99686f5b29da8b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0888a760b8fd58de0dd269bb34b01d89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga0888a760b8fd58de0dd269bb34b01d89">PyPO.System.System.createGaussian</a> (self, gaussDict, name_surface)</td></tr>
<tr class="memdesc:ga0888a760b8fd58de0dd269bb34b01d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vectorial Gaussian beam.  <br /></td></tr>
<tr class="separator:ga0888a760b8fd58de0dd269bb34b01d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e31bc6c7530eb146ff23497869e61e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga45e31bc6c7530eb146ff23497869e61e">PyPO.System.System.createScalarGaussian</a> (self, gaussDict, name_surface)</td></tr>
<tr class="memdesc:ga45e31bc6c7530eb146ff23497869e61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scalar Gaussian beam.  <br /></td></tr>
<tr class="separator:ga45e31bc6c7530eb146ff23497869e61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4764abb8d6299b1390b3fdeaf3412dad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga4764abb8d6299b1390b3fdeaf3412dad">PyPO.System.System.calcSpillover</a> (self, name_field, comp, aperDict)</td></tr>
<tr class="memdesc:ga4764abb8d6299b1390b3fdeaf3412dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate spillover efficiency of a beam defined on a surface.  <br /></td></tr>
<tr class="separator:ga4764abb8d6299b1390b3fdeaf3412dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a43571e48e4844c7bae0706ecaa437"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#gab6a43571e48e4844c7bae0706ecaa437">PyPO.System.System.calcTaper</a> (self, name_field, comp, aperDict=None)</td></tr>
<tr class="memdesc:gab6a43571e48e4844c7bae0706ecaa437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate taper efficiency of a beam defined on a surface.  <br /></td></tr>
<tr class="separator:gab6a43571e48e4844c7bae0706ecaa437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07727e8bdbf38d793002b6b4ee3df315"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga07727e8bdbf38d793002b6b4ee3df315">PyPO.System.System.calcXpol</a> (self, name_field, comp_co, comp_cr)</td></tr>
<tr class="memdesc:ga07727e8bdbf38d793002b6b4ee3df315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cross-polar efficiency of a field defined on a surface.  <br /></td></tr>
<tr class="separator:ga07727e8bdbf38d793002b6b4ee3df315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec40a858972caccad3905b94c964aa3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga9ec40a858972caccad3905b94c964aa3">PyPO.System.System.fitGaussAbs</a> (self, name_field, comp, thres=None, mode=Modes.LIN, full_output=False, ratio=1)</td></tr>
<tr class="memdesc:ga9ec40a858972caccad3905b94c964aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a Gaussian profile to the amplitude of a field component and adds the result to scalar field in system.  <br /></td></tr>
<tr class="separator:ga9ec40a858972caccad3905b94c964aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c4eedbc5e3aa4a675261751a4f865e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#gab2c4eedbc5e3aa4a675261751a4f865e">PyPO.System.System.calcMainBeam</a> (self, name_field, comp, thres=None, mode=Modes.LIN)</td></tr>
<tr class="memdesc:gab2c4eedbc5e3aa4a675261751a4f865e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate main-beam efficiency of a beam pattern.  <br /></td></tr>
<tr class="separator:gab2c4eedbc5e3aa4a675261751a4f865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8e0bc6a4c9273a1e41897d5da6166a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga4f8e0bc6a4c9273a1e41897d5da6166a">PyPO.System.System.calcBeamCuts</a> (self, name_field, comp, phi=0, center=True, align=True, norm=False, transform=False, mode=Modes.dB)</td></tr>
<tr class="memdesc:ga4f8e0bc6a4c9273a1e41897d5da6166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cross sections of a beam pattern.  <br /></td></tr>
<tr class="separator:ga4f8e0bc6a4c9273a1e41897d5da6166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b301243f7f2b4db848e244c729876a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga70b301243f7f2b4db848e244c729876a">PyPO.System.System.calcHPBW</a> (self, name_field, comp, interp=50, center=False, align=False)</td></tr>
<tr class="memdesc:ga70b301243f7f2b4db848e244c729876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate half-power beamwidth.  <br /></td></tr>
<tr class="separator:ga70b301243f7f2b4db848e244c729876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df4f35ded77084223c1b314ce2375c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga0df4f35ded77084223c1b314ce2375c6">PyPO.System.System.createPointSource</a> (self, PSDict, name_surface)</td></tr>
<tr class="memdesc:ga0df4f35ded77084223c1b314ce2375c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate point-source PO fields and currents.  <br /></td></tr>
<tr class="separator:ga0df4f35ded77084223c1b314ce2375c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a0521ce33860e99c09e5acc36af9f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga27a0521ce33860e99c09e5acc36af9f4">PyPO.System.System.createUniformSource</a> (self, UDict, name_surface)</td></tr>
<tr class="memdesc:ga27a0521ce33860e99c09e5acc36af9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate uniform PO fields and currents.  <br /></td></tr>
<tr class="separator:ga27a0521ce33860e99c09e5acc36af9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ef9e2a4c4eb4b4fbe880465e147d65"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga95ef9e2a4c4eb4b4fbe880465e147d65">PyPO.System.System.createPointSourceScalar</a> (self, PSDict, name_surface)</td></tr>
<tr class="memdesc:ga95ef9e2a4c4eb4b4fbe880465e147d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate point-source scalar PO field.  <br /></td></tr>
<tr class="separator:ga95ef9e2a4c4eb4b4fbe880465e147d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293294dee89beead87d829616ddc4a3e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga293294dee89beead87d829616ddc4a3e">PyPO.System.System.createUniformSourceScalar</a> (self, UDict, name_surface)</td></tr>
<tr class="memdesc:ga293294dee89beead87d829616ddc4a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate scalar uniform PO fields and currents.  <br /></td></tr>
<tr class="separator:ga293294dee89beead87d829616ddc4a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b62bd1bfc8e7103b5eb3e105d5e28f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#gab0b62bd1bfc8e7103b5eb3e105d5e28f">PyPO.System.System.interpBeam</a> (self, name, gridsize_new, obj_t=&quot;fields&quot;)</td></tr>
<tr class="memdesc:gab0b62bd1bfc8e7103b5eb3e105d5e28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a PO beam.  <br /></td></tr>
<tr class="separator:gab0b62bd1bfc8e7103b5eb3e105d5e28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fed5a1920ada927ea8712fae363d31f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public__api__po.html#ga9fed5a1920ada927ea8712fae363d31f">PyPO.System.System.autoConverge</a> (self, source_field, name_target, tol=1e-2, <a class="el" href="GUtils_8h.html#a8ef9560cf95b6226aebec0b889ef1460">add</a>=10, patch_size=1/9, max_iter=1000)</td></tr>
<tr class="memdesc:ga9fed5a1920ada927ea8712fae363d31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate gridsize for which calculation converges.  <br /></td></tr>
<tr class="separator:ga9fed5a1920ada927ea8712fae363d31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This section contains a list of public <code>PyPO</code> methods which are used for performing physical optics related tasks. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9fed5a1920ada927ea8712fae363d31f" name="ga9fed5a1920ada927ea8712fae363d31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fed5a1920ada927ea8712fae363d31f">&#9670;&#160;</a></span>autoConverge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.autoConverge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patch_size</em> = <code>1/9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate gridsize for which calculation converges. </p>
<p>This function calculates the gridsize for a target surface in order to obtain a convergent solution. First, a small patch is selected from the middle of the target surface and given a starting gridsize. The brightest component of the source distribution is then selected and copied into a PO scalarfield object. The scalarfield is propagated to the target patch and the total incident power is calculated. Then, the propagation is performed again but now the gridsize of the patch is smaller. The power is calculated again and compared with the previous result. If this result is smaller than the given tolerance, the new gridsize is accepted as the converged gridsize. If not, another iteration is started. If the maximal number of iterations is exceeded, <code>PyPO</code> will throw an error and stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_field</td><td>Name of field to use for auto convergence. Should be the field that is to be propagated. </td></tr>
    <tr><td class="paramname">name_target</td><td>Name of target surface. </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance for specifying when convergence has been reached. </td></tr>
    <tr><td class="paramname">add</td><td>Increment in gridsize for each iteration. </td></tr>
    <tr><td class="paramname">patch_size</td><td>Factor for reducing size of target in order to save time. Should be smaller than 1. </td></tr>
    <tr><td class="paramname">max_iter</td><td>Maximum number of iterations before auto convergence errors.</td></tr>
    <tr><td class="paramname">returns</td><td>gridsize Gridsize, scaled to full target, for which solution converged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f8e0bc6a4c9273a1e41897d5da6166a" name="ga4f8e0bc6a4c9273a1e41897d5da6166a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f8e0bc6a4c9273a1e41897d5da6166a">&#9670;&#160;</a></span>calcBeamCuts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.calcBeamCuts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phi</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Modes.dB</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate cross sections of a beam pattern. </p>
<p>This method calculates cross sections along the cardinal planes of the beam pattern. The cardinal planes here are defined to lie along the semi-major and semi-minor axes of the beam pattern. It does this by first finding the center and position angle of the beam pattern. Then, it creates a snapshot of the current configuration and translates and rotates the beam pattern so that the cardinal planes are oriented along the x- and y-axes. It is also possible to not do this and instead directly calculate the cross sections along the x- and y-axes as-is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of field object. </td></tr>
    <tr><td class="paramname">comp</td><td>Component of field object. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">phi</td><td>Manual rotation of cuts w.r.t. to the x-y cardinal planes. </td></tr>
    <tr><td class="paramname">center</td><td>Whether to center the cardinal planes on the peak of the beam pattern. </td></tr>
    <tr><td class="paramname">align</td><td>Whether to align the cardinal planes to the beam pattern minor and major axes. </td></tr>
    <tr><td class="paramname">norm</td><td>Which component to normalise to. Defaults to comp. </td></tr>
    <tr><td class="paramname">transform</td><td>Transform surface on which beam is defined. If False, will evaluate beam cuts as if surface is in restframe. </td></tr>
    <tr><td class="paramname">mode</td><td>Return beamcuts in linear or decibel values. Instance of Modes enum object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x_cut Beam cross section along the E-plane. </dd>
<dd>
y_cut Beam cross section along the H-plane. </dd>
<dd>
x_strip Co-ordinate values for x_cut. </dd>
<dd>
y_strip Co-ordinate values for y_cut. </dd></dl>

</div>
</div>
<a id="ga70b301243f7f2b4db848e244c729876a" name="ga70b301243f7f2b4db848e244c729876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70b301243f7f2b4db848e244c729876a">&#9670;&#160;</a></span>calcHPBW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.calcHPBW </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interp</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate half-power beamwidth. </p>
<p>This is done by directly evaluating the -3 dB points along both cardinal planes of the beam pattern. Then, the distance between antipodal half-power points is calculated on an interpolation of the supplied PO field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of field object. </td></tr>
    <tr><td class="paramname">comp</td><td>Component of field object. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">interp</td><td>Interpolation factor for finding the HPBW. Defaults to 50. </td></tr>
    <tr><td class="paramname">center</td><td>Whether to center the beam cuts on amplitude center. Use only if beam has well defined amplitude center. </td></tr>
    <tr><td class="paramname">align</td><td>Whether to take beam cuts along cardinal planes rotated by the position angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HPBW_E Half-power beamwidth along E-plane in units of surface of beam. </dd>
<dd>
HPBW_H Half-power beamwidth along H-plane in units of surface of beam. </dd></dl>

</div>
</div>
<a id="gab2c4eedbc5e3aa4a675261751a4f865e" name="gab2c4eedbc5e3aa4a675261751a4f865e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c4eedbc5e3aa4a675261751a4f865e">&#9670;&#160;</a></span>calcMainBeam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.calcMainBeam </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>thres</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Modes.LIN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate main-beam efficiency of a beam pattern. </p>
<p>The main-beam efficiency is calculated by fitting a Gaussian amplitude profile to the central lobe. This might reuire fine-tuning the "thres" parameter, or changing the space in whcih to fit by supplying the "mode" parameter. Then, the efficiency is defined as the fraction of power in the Gaussian w.r.t. the full pattern. Designed for far-field beam patterns, but also applicable to regular fields. Note that since this method uses the fitGaussAbs() method, the result is quite sensitive to initial conditions and should therefore be (iteratively) checked for robustness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of field object. </td></tr>
    <tr><td class="paramname">comp</td><td>Component of field object. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">thres</td><td>Threshold to fit to, in decibels. </td></tr>
    <tr><td class="paramname">mode</td><td>Fit to amplitude in decibels, linear or logarithmically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eff Main-beam efficiency. </dd></dl>

</div>
</div>
<a id="ga4764abb8d6299b1390b3fdeaf3412dad" name="ga4764abb8d6299b1390b3fdeaf3412dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4764abb8d6299b1390b3fdeaf3412dad">&#9670;&#160;</a></span>calcSpillover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.calcSpillover </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aperDict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate spillover efficiency of a beam defined on a surface. </p>
<p>The method calculates the spillover using the fraction of the beam that illuminates the region defined in aperDict versus the total beam.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of the PO field. </td></tr>
    <tr><td class="paramname">comp</td><td>Component of field to calculate spillover of. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">aperDict</td><td>An aperDict dictionary containing the parameters for defining the spillover aperture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>spill The spillover efficiency.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>aperDict </dd></dl>

</div>
</div>
<a id="gab6a43571e48e4844c7bae0706ecaa437" name="gab6a43571e48e4844c7bae0706ecaa437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a43571e48e4844c7bae0706ecaa437">&#9670;&#160;</a></span>calcTaper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.calcTaper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aperDict</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate taper efficiency of a beam defined on a surface. </p>
<p>The method calculates the taper efficiency using the fraction of the beam that illuminates the region defined in aperDict versus the total beam. If aperDict is not given, it will calculate the taper efficiency on the entire beam.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of the PO field. </td></tr>
    <tr><td class="paramname">comp</td><td>Component of field to calculate taper efficiency of. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">aperDict</td><td>An aperDict dictionary containing the parameters for defining the taper aperture. Defaults to None.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>taper The taper efficiency.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>aperDict </dd></dl>

</div>
</div>
<a id="ga07727e8bdbf38d793002b6b4ee3df315" name="ga07727e8bdbf38d793002b6b4ee3df315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07727e8bdbf38d793002b6b4ee3df315">&#9670;&#160;</a></span>calcXpol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.calcXpol </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp_co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp_cr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate cross-polar efficiency of a field defined on a surface. </p>
<p>The cross-polar efficiency is described as the ratio of power in the cross-polar component versus the co-polar component. The cross-polar efficiency is calculated over the entire field extent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of the PO field. </td></tr>
    <tr><td class="paramname">comp_co</td><td>Co-polar component of field. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">comp_cr</td><td>Cross-polar component of field. Instance of FieldComponents enum object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>crp The cross-polar efficiency. </dd></dl>

</div>
</div>
<a id="ga0888a760b8fd58de0dd269bb34b01d89" name="ga0888a760b8fd58de0dd269bb34b01d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0888a760b8fd58de0dd269bb34b01d89">&#9670;&#160;</a></span>createGaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.createGaussian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gaussDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vectorial Gaussian beam. </p>
<p>This method creates a general, potentially astigmatic, vectorial Gaussian beam. The beam is evaluated with the focus at z = 0. The surface on which the beam is calculated, defined by "name_source", does not have to lie in or be parallel to the xy-plane. Instead, the Gaussian beam is evaluated on the surface as-is, evaluating the Gaussian beam at the xyz-points on the surface. Still, the focus is at z = 0. If one wishes to displace the focal point, the PO fields and currents need to be translated after generating the Gaussian beam.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussDict</td><td>A GDict containing parameters for the Gaussian beam. </td></tr>
    <tr><td class="paramname">name_surface</td><td>Name of plane on which to define Gaussian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GDict </dd></dl>

</div>
</div>
<a id="ga0df4f35ded77084223c1b314ce2375c6" name="ga0df4f35ded77084223c1b314ce2375c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0df4f35ded77084223c1b314ce2375c6">&#9670;&#160;</a></span>createPointSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.createPointSource </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PSDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate point-source PO fields and currents. </p>
<p>The point source is generated in the center of the source surface given by "name_surface". It is generally a good idea to make this source surface as small as possible, in order to create a "nice" point source. If this is too big, the resulting PO field more closely resembles a uniformly illuminated square. The H-field is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PSDict</td><td>A PSDict dictionary, containing parameters for the point source. </td></tr>
    <tr><td class="paramname">name_surface</td><td>Name of surface on which to define the point-source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PSDict </dd></dl>

</div>
</div>
<a id="ga95ef9e2a4c4eb4b4fbe880465e147d65" name="ga95ef9e2a4c4eb4b4fbe880465e147d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95ef9e2a4c4eb4b4fbe880465e147d65">&#9670;&#160;</a></span>createPointSourceScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.createPointSourceScalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>PSDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate point-source scalar PO field. </p>
<p>The point source is generated in the center of the source surface given by "name_surface". It is generally a good idea to make this source surface as small as possible, in order to create a "nice" point source. If this is too big, the resulting PO field more closely resembles a uniformly illuminated square. The H-field is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PSDict</td><td>A PSDict dictionary, containing parameters for the point source. </td></tr>
    <tr><td class="paramname">name_surface</td><td>Name of surface on which to define the point-source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PSDict </dd></dl>

</div>
</div>
<a id="ga45e31bc6c7530eb146ff23497869e61e" name="ga45e31bc6c7530eb146ff23497869e61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e31bc6c7530eb146ff23497869e61e">&#9670;&#160;</a></span>createScalarGaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.createScalarGaussian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gaussDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scalar Gaussian beam. </p>
<p>This method creates a general, potentially astigmatic, scalar Gaussian beam. The beam is evaluated with the focus at z = 0. The surface on which the beam is calculated, defined by "name_source", does not have to lie in or be parallel to the xy-plane. Instead, the Gaussian beam is evaluated on the surface as-is, evaluating the Gaussian beam at the xyz-points on the surface. Still, the focus is at z = 0. If one wishes to displace the focal point, the PO scalarfield needs to be translated after generating the Gaussian beam.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussDict</td><td>A GDict containing parameters for the Gaussian beam. </td></tr>
    <tr><td class="paramname">name_surface</td><td>Name of plane on which to define Gaussian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SGDict </dd></dl>

</div>
</div>
<a id="ga27a0521ce33860e99c09e5acc36af9f4" name="ga27a0521ce33860e99c09e5acc36af9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a0521ce33860e99c09e5acc36af9f4">&#9670;&#160;</a></span>createUniformSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.createUniformSource </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>UDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate uniform PO fields and currents. </p>
<p>The uniform field is generated by defining a PO field on the source surface and setting all values to the amplitude specified in the input dictionary. The H-field is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UDict</td><td>A UDict dictionary, containing parameters for the uniform pattern. </td></tr>
    <tr><td class="paramname">name_surface</td><td>Name of surface on which to define the uniform pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PSDict </dd></dl>

</div>
</div>
<a id="ga293294dee89beead87d829616ddc4a3e" name="ga293294dee89beead87d829616ddc4a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293294dee89beead87d829616ddc4a3e">&#9670;&#160;</a></span>createUniformSourceScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.createUniformSourceScalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>UDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate scalar uniform PO fields and currents. </p>
<p>The uniform field is generated by defining a PO field on the source surface and setting all values to the amplitude specified in the input dictionary. The H-field is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UDict</td><td>A UDict dictionary, containing parameters for the uniform pattern. </td></tr>
    <tr><td class="paramname">name_surface</td><td>Name of surface on which to define the uniform pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>UDict </dd></dl>

</div>
</div>
<a id="ga9ec40a858972caccad3905b94c964aa3" name="ga9ec40a858972caccad3905b94c964aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec40a858972caccad3905b94c964aa3">&#9670;&#160;</a></span>fitGaussAbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.fitGaussAbs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>thres</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Modes.LIN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a Gaussian profile to the amplitude of a field component and adds the result to scalar field in system. </p>
<p>The resultant Gaussian fit cannot be propagated using vectorial means, but can be propagated using scalar propagation. Note that this method is very sensitive to initial conditions, especially when the beam pattern to which to fit the Gaussian has multiple maxima or is generally ill-described by a Gaussian. In the latter case, the method may fail altogether.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_field</td><td>Name of field object. </td></tr>
    <tr><td class="paramname">comp</td><td>Component of field object. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">thres</td><td>Threshold to fit to, in decibels. </td></tr>
    <tr><td class="paramname">mode</td><td>Fit to amplitude in decibels, linear or logarithmically. Instance of Modes enum object. </td></tr>
    <tr><td class="paramname">full_output</td><td>Return fitted parameters and standard deviations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>popt Fitted beam parameters. </dd>
<dd>
perr Standard deviation of fitted parameters. </dd></dl>

</div>
</div>
<a id="gab0b62bd1bfc8e7103b5eb3e105d5e28f" name="gab0b62bd1bfc8e7103b5eb3e105d5e28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b62bd1bfc8e7103b5eb3e105d5e28f">&#9670;&#160;</a></span>interpBeam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.interpBeam </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gridsize_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj_t</em> = <code>&quot;fields&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a PO beam. </p>
<p>Only for beams defined on planar surfaces.</p>
<p>Can interpolate PO fields and currents separately. Results are stored in a new PO fields/currents object with the original name appended by 'interp'. Also, a new plane will be created with the updated gridsize and name appended by 'interp'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of beam to be interpolated. </td></tr>
    <tr><td class="paramname">gridsize_new</td><td>New gridsizes for interpolation. </td></tr>
    <tr><td class="paramname">obj</td><td>Whether to interpolate currents or fields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83eea20f5bdafb3f99686f5b29da8b5f" name="ga83eea20f5bdafb3f99686f5b29da8b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83eea20f5bdafb3f99686f5b29da8b5f">&#9670;&#160;</a></span>mergeBeams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.mergeBeams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>beams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em> = <code>&quot;fields&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>merged_name</em> = <code>&quot;combined&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge multiple beams that are defined on the same surface. </p>
<p>The beams to be merged are first checked to see if they are all defined on the same surface. Then, a new PO field or current is defined in the internal dictionary with the new name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beams</td><td>Fields or currents objects to merge. </td></tr>
    <tr><td class="paramname">obj</td><td>Whether the beams are PO fields or currents. </td></tr>
    <tr><td class="paramname">merged_name</td><td>Name of merged object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4cdcd5c907622e6f18bfabcf32dec6f6" name="ga4cdcd5c907622e6f18bfabcf32dec6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cdcd5c907622e6f18bfabcf32dec6f6">&#9670;&#160;</a></span>readCustomBeam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.readCustomBeam </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_beam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a custom beam from disk into the system. </p>
<p>The system will look in the customBeamPath, which defaults to the current working directory and can be set with the setCustomBeamPath() method. Note that the custom beam pattern needs to contain a real and imaginary part, and that these need to be stored in separate .txt files, stored as such: r&lt;name_beam&gt;.txt and i&lt;name_beam&gt;.txt, where 'r' and 'i' refer to the real and imaginary part, respectively. If the beam pattern is a component of the E-field, the currents will be calculated assuming a PMC surface. If, on the other hand, the beam pattern is a component of the H-field, the currents will be calculated assuming a PEC surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_beam</td><td>Name of the beam (without the 'r' or 'i' prefixes or '.txt' suffix). </td></tr>
    <tr><td class="paramname">name_source</td><td>Name of source surface on which to define the beam. </td></tr>
    <tr><td class="paramname">comp</td><td>Polarisation component of beam. Instance of FieldComponents enum object. </td></tr>
    <tr><td class="paramname">lam</td><td>Wavelength of beam, in mm. </td></tr>
    <tr><td class="paramname">normalise</td><td>Whether or not to normalise beam to its maximum amplitude. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor for beam. Defaults to 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>setCustomBeamPath </dd></dl>

</div>
</div>
<a id="gaff726434bebd8ed64fd20f1cc141a080" name="gaff726434bebd8ed64fd20f1cc141a080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff726434bebd8ed64fd20f1cc141a080">&#9670;&#160;</a></span>removeCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.removeCurrent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>currentName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a PO current from system. </p>
<p>This method takes the name of an internally stored PO current object and removes it from the internal dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curentName</td><td>Name of current to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d822ec75ec733bede10f444be4d1479" name="ga2d822ec75ec733bede10f444be4d1479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d822ec75ec733bede10f444be4d1479">&#9670;&#160;</a></span>removeField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.removeField </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a PO field from system. </p>
<p>This method takes the name of an internally stored PO field object and removes it from the internal dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>Name of field to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf38481699a40b1e3044083a8382b8e7b" name="gaf38481699a40b1e3044083a8382b8e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf38481699a40b1e3044083a8382b8e7b">&#9670;&#160;</a></span>removeScalarField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.removeScalarField </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a scalar PO field from system. </p>
<p>This method takes the name of an internally stored PO scalarfield object and removes it from the internal dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>Name of scalar field to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1632938e4cddce095271eba8fcc30910" name="ga1632938e4cddce095271eba8fcc30910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1632938e4cddce095271eba8fcc30910">&#9670;&#160;</a></span>runPO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def PyPO.System.System.runPO </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>runPODict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate a PO propagation. </p>
<p>Stores desired output in the internal fields and/or internal currents dictionary. If the 'EHP' mode is selected, the reflected Poynting frame is stored in the internal frame dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PODict</td><td>Dictionary containing the PO propagation instructions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PODict </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
